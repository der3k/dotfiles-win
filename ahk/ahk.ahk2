#Requires AutoHotkey v2.0
#SingleInstance Force
InstallKeybdHook()
Persistent()
A_HotkeyInterval := 100

SetKeyDelay(-1)

TraySetIcon(A_ScriptDir "\ahk.ico")

; ------------------------------------------------------------------------
; Constants
; ------------------------------------------------------------------------
EDGE_TOLERANCE := 5
BORDER_COMPENSATION := 18
WM_COMMAND := 0x111
EXPLORER_NEW_FOLDER := 41504
TILING_STEPS := [0.25, 1 / 3, 0.5, 2 / 3]

; ------------------------------------------------------------------------
; Environment
; ------------------------------------------------------------------------
home := EnvGet("USER_HOME") || A_MyDocuments "\.."
desktop := EnvGet("USER_DESKTOP") || A_Desktop
console := EnvGet("USER_CONSOLE") || "wt.exe"
editor := EnvGet("USER_EDITOR") || "notepad.exe"
viewer := EnvGet("USER_VIEWER") || "explorer.exe"

SetWorkingDir(desktop)

:O*:e,,::rsi.news@quick.cz
:O*:eg,,::richard.sikora@gmail.com
:O*:et,,::richard.sikora@tietoevry.com
:O*:t,,::739524873
:O*:s,,::Slezská 1851/40
:TO*:n,,::Nádražní 42/4
:O*:c,,::Český Těšín
:O*:p,,::73701
:O*:o,,::012846595

+<^h:: PadWindow("left")
+<^l:: PadWindow("right")

+<^i:: { ; CENTER
    global EDGE_TOLERANCE, BORDER_COMPENSATION
    maximized := WinGetMinMax("A")
    if (maximized = 1) {
        WinRestore("A")
        return
    }
    GetActiveMonitorWorkArea(&mX, &mY, &mW, &mH)
    WinGetPos(&x, &y, &w, &h, "A")
    mRight := mX + mW
    relWidth := Round((w / mW) * 100, 2)
    bc := BORDER_COMPENSATION
    if (relWidth > 33.33 || (x <= mX && relWidth > 25) || (x + w >= (mRight - EDGE_TOLERANCE) && relWidth > 25)) {
        WinMove(mX + mW / 3 - bc, mY, mW / 3 + bc * 2, mH, "A")
    } else {
        WinMove(mX + mW / 4 - bc, mY, mW / 2 + bc * 2, mH, "A")
    }
}

+<^k:: { ; UP
    GetActiveMonitorWorkArea(&mX, &mY, &mW, &mH)
    WinGetPos(&x, &y, &w, &h, "A")
    if (h < mH) {
        ; ? + up => full height
        WinMove(x, mY, w, mH, "A")
    } else {
        ; full height + up => top half height
        WinMove(x, mY, w, mH / 2, "A")
    }
}

+<^j:: { ; DOWN
    GetActiveMonitorWorkArea(&mX, &mY, &mW, &mH)
    WinGetPos(&x, &y, &w, &h, "A")
    if (h < mH) {
        ; ? + down => full height
        WinMove(x, mY, w, mH, "A")
    } else {
        ; full height + down => bottom half height
        WinMove(x, mY + mH / 2, w, mH / 2, "A")
    }
}

*<!n:: WinMinimize("A")

*<!m:: {
    if WinActive("ahk_exe CDViewer.exe") {
        SendInput("^q")
    } else {
        Send("{Alt down}{Tab}{Alt up}")
    }
}

+<^r:: Reload()

#a:: {
    A_Clipboard := A_Clipboard  ; strip formatting
}

#^t:: {
    timeStamp := FormatTime(, "yyyy-MM-dd HH:mm:ss")
    SendInput(timeStamp)
}

#HotIf WinActive("ahk_exe alacritty.exe")
;  <^k::Send("{Blind}!k")
#HotIf

; Directory window & Explorer
GroupAdd("ExplorerGroup", "ahk_class CabinetWClass")
GroupAdd("ExplorerGroup", "ahk_class ExploreWClass")

#HotIf WinActive("ahk_group ExplorerGroup")
F3:: openSelectionInViewer()
;F4::openSelection()
;+F4::createFileFromWinTitle()
F7:: createDirFromWinTitle()
^d:: openDosFromWinTitle()
#HotIf

openDosFromWinTitle() {
    global console
    dir := getExplorerPath()
    if !dir
        dir := WinGetTitle("A")
    safeDir := StrReplace(dir, '"', '""')
    Run(console ' -d "' safeDir '"')
}

openSelection() {
    global editor
    selection := getSelection()
    if !selection
        return
    try
        attribs := FileGetAttrib(selection)
    catch
        return
    if InStr(attribs, "D")
        openDir(selection)
    else
        Run(editor ' "' selection '"')
}

openDir(path) {
    Run('explorer /n,"' path '"')
}

getDirFromWinTitle() {
    dir := getExplorerPath()
    return dir ? dir : WinGetTitle("A")
}

createDirFromWinTitle() {
    dir := getExplorerPath()
    if !dir
        dir := WinGetTitle("A")
    createDirOnPath(dir)
}

createDirOnPath(dir) {
    result := InputBox("", "New folder name", "w300 h100")
    if (result.Result != "OK")
        return
    path := dir "\" result.Value "\"
    DirCreate(path)
    openDir(path)
}

createFileFromWinTitle() {
    dir := getExplorerPath()
    if !dir
        dir := WinGetTitle("A")
    createFileOnPath(dir)
}

createFileOnPath(dir) {
    global editor
    result := InputBox("", "New file name", "w300 h100")
    if (result.Result != "OK")
        return
    path := dir "\" result.Value
    FileAppend("", path)
    Run(editor ' "' path '"')
}

createDir() {
    global WM_COMMAND, EXPLORER_NEW_FOLDER
    PostMessage(WM_COMMAND, EXPLORER_NEW_FOLDER, 0)  ; refresh
    SendInput("{AppsKey}wf")
}

openSelectionInViewer() {
    global viewer
    selection := getSelection()
    if !selection
        return
    Run(viewer ' "' selection '"')
}

#+q:: WinSetAlwaysOnTop(-1, "A")

+<^`;:: {
    showHideAppWin("ahk_exe alacritty.exe",
        "C:\Program Files\Alacritty\alacritty.exe --config-file C:\home\etc\dotfiles\alacritty\alacritty.toml")
}

; ------------------------------------------------------------------------
; Functions
; ------------------------------------------------------------------------

PadWindow(direction) {
    global TILING_STEPS, EDGE_TOLERANCE
    if (WinGetMinMax("A") = 1)
        WinRestore("A")
    GetActiveMonitorWorkArea(&mX, &mY, &mW, &mH)
    WinGetPos(&x, &y, &w, &h, "A")
    mRight := mX + mW
    relWidth := Round((w / mW) * 100, 2)
    isLeft := (direction = "left")
    isAligned := isLeft ? (x <= mX) : (x + w >= mRight - EDGE_TOLERANCE)

    if !isAligned {
        ; Not aligned yet => snap to edge at 33%
        fraction := mW / 3
        newX := isLeft ? mX : mRight - fraction
        WinMove(newX, mY, fraction, mH, "A")
        return
    }
    ; Cycle through tiling sizes: 25% → 33% → 50% → 66% → 25%
    nextFraction := mW * TILING_STEPS[1]  ; default wrap to 25%
    for i, step in TILING_STEPS {
        if (relWidth <= step * 100 + 0.5 && i < TILING_STEPS.Length) {
            nextFraction := mW * TILING_STEPS[i + 1]
            break
        }
    }
    newX := isLeft ? mX : mRight - nextFraction
    WinMove(newX, y, nextFraction, h, "A")
}

GetActiveMonitorWorkArea(&mX, &mY, &mW, &mH) {
    WinGetPos(&wx, &wy, &ww, &wh, "A")
    cx := wx + ww / 2
    cy := wy + wh / 2
    count := MonitorGetCount()
    loop count {
        MonitorGetWorkArea(A_Index, &left, &top, &right, &bottom)
        if (cx >= left && cx < right && cy >= top && cy < bottom) {
            mX := left, mY := top, mW := right - left, mH := bottom - top
            return
        }
    }
    ; Fallback to primary monitor
    MonitorGetWorkArea(MonitorGetPrimary(), &left, &top, &right, &bottom)
    mX := left, mY := top, mW := right - left, mH := bottom - top
}

getSelection() {
    theClipboard := ClipboardAll()
    A_Clipboard := ""
    Send("^c")
    if !ClipWait(1) {
        A_Clipboard := theClipboard
        return ""
    }
    selection := A_Clipboard
    A_Clipboard := theClipboard
    return selection
}

getExplorerPath() {
    try {
        hwnd := WinGetID("A")
        shell := ComObject("Shell.Application")
        for window in shell.Windows {
            try {
                if (window.HWND = hwnd) {
                    return window.Document.Folder.Self.Path
                }
            }
        }
    }
    return ""
}

showHideAppWin(winTitle, appPath) {
    if WinExist(winTitle) {
        if WinActive(winTitle) {
            Send("!{Tab}")
        } else {
            WinActivate()
        }
    } else {
        Run(appPath)
    }
}

showAppWin(winTitle, appPath) {
    if WinExist(winTitle) {
        WinActivate()
    } else {
        Run(appPath)
    }
}

;---
; Vim layer
;---

Escape:: Send("{Blind}{Escape}")

Escape & h:: Send("{Blind}{Left}")
Escape & j:: Send("{Blind}{Down}")
Escape & k:: Send("{Blind}{Up}")
Escape & l:: Send("{Blind}{Right}")

Escape & w:: Send("{Blind}^{Right}")
Escape & b:: Send("{Blind}^{Left}")

Escape & 4:: Send("{Blind}{End}")
Escape & 0:: Send("{Blind}{Home}")

Escape & `;:: Send("{Blind}{Backspace}")
Escape & p:: Send("{Blind}{Del}")

Escape & ':: Send("{Blind}^{Backspace}")

Escape & m::AltTab
;Escape & n::WinMinimize("A")
Escape & .:: Send("{Blind}^s")

Escape & Space:: Send("{Blind}!{Space}")

Escape & [:: Send("{Blind}^#{Left}")
Escape & ]:: Send("{Blind}^#{Right}")
